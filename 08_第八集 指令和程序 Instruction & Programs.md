# 计算机科学速成课 Crash Course Computer Science

## 第八集 指令和程序（Instructions & Programs）

---

### **核心目标：理解CPU如何执行指令与程序**
- **问题起点**：上集构建了基础CPU (**把ALU 控制单元 RAM 时钟结合在一起**)，但缺乏实际指令集来实现复杂功能                       
- **关键突破**：通过**指令集架构(ISA)** 将硬件能力转化为软件可编程性
- **核心理念**：**程序**是CPU的"思维"，**指令**是其基本"词汇"

> 💡 **Carrie Anne 的洞见**：  
> *"CPU是硬件，但它的力量来自软件——  
> 不同的指令序列让同一块芯片完成不同任务，  
> 这就是可编程计算机的魔力所在！"*
> CPU之所以强大，是因为他是可编程的

![image-20250909194737378](https://gitee.com/zhang-hao688/PicGO/raw/master/images/image-20250909194737378.png)

![image-20250909195119143](https://gitee.com/zhang-hao688/PicGO/raw/master/images/image-20250909195119143.png)

---

### **指令基础：从二进制到可读指令**
#### 1. **指令结构（8位示例）**
| 位数 | 0-3 (4位)          | 4-7 (4位)           |
| ---- | ------------------ | ------------------- |
| 作用 | **操作码(Opcode)** | **操作数(Operand)** |
| 示例 | `0010` = LOAD_A    | `1110` = 地址14     |
| 含义 | **做什么**         | **对谁做**          |

#### 2. **指令编码的抽象表示**                   
   - 二进制 `0010 1110` → 人类可读 `LOAD_A 14`
   - 二进制 `1000 0100` → 人类可读 `ADD B A`
   -  **关键意义**：程序员无需记忆二进制，只需理解指令语义

#### 3. **冯·诺依曼架构的体现**
   - **指令与数据共存RAM**：**内存中既有程序指令也有操作数据**
   - **无本质区别**：`00101110` 可能是数据也可能是指令
   - **HALT指令的作用**：标记程序结束，区分指令与数据

---

### **核心指令类型及功能**
#### 1. **数据传输指令**

![](https://gitee.com/zhang-hao688/PicGO/raw/master/images/image-20250909195119143.png)

| 指令           | 功能                | 示例                                             |
| -------------- | ------------------- | ------------------------------------------------ |
| LOAD_A         | 从内存加载到寄存器A | `LOAD_A 14` → 从地址14中拿到数字3→寄存器A        |
| STORE_A        | 从寄存器A存到内存   | `STORE_A 13` → 寄存器A→地址13                    |
| LOAD_B/STORE_B | 寄存器B的对应操作   | `LOAD_B 15` → 从地址15中拿到数字14 ，放入寄存器B |

#### 2. **算术指令**
| 指令         | 功能      | 执行规则                                  |
| ------------ | --------- | ----------------------------------------- |
| ADD B A      | A = A + B | **结果存入第二个寄存器** B和A的顺序很重要 |
| SUB B A      | A = A - B | 11-5=6 → 寄存器A=6                        |
| **关键机制** | ALU标志位 | 负数结果→设置"负数标志"                   |

#### 3. **控制流指令**

![image-20250909200405041](https://gitee.com/zhang-hao688/PicGO/raw/master/images/image-20250909200405041.png)

| 指令            | 类型         | 工作原理                                |
| --------------- | ------------ | --------------------------------------- |
| JUMP 2          | 无条件跳转   | 覆盖指令地址寄存器为2，程序跳转到新位置 |
| JUMP_NEGATIVE 5 | **条件跳转** | 仅当ALU负数标志=1时跳转                 |
| HALT            | 程序终止     | 停止CPU执行                             |

> ✅ **条件跳转的核心价值**：实现程序分支与循环控制

---

### **程序执行案例：从简单计算到条件循环**

![image-20250909202438641](https://gitee.com/zhang-hao688/PicGO/raw/master/images/image-20250909202438641.png)

#### 1. **基础计算示例（4指令）**
   ```assembly
   LOAD_A 14   ; 地址14的值(3) → 寄存器A
   LOAD_B 15   ; 地址15的值(14) → 寄存器B
   ADD B A     ; A = A + B = 17
   STORE_A 13  ; A → 地址13
   ```
   **结果**：3 + 14 = 17 存入内存

#### 2. **无限循环陷阱（缺少条件判断）**
   ```assembly
   LOAD_A 14   ; A=1
   LOAD_B 15   ; B=1
   ADD B A     ; A=2
   STORE_A 13  ; 存结果
   JUMP 2      ; 永远跳回ADD
   HALT        ; 永远执行不到
   ```
   **问题**：无限循环（程序永远无法终止）

#### 3. **条件循环实现（余数计算）**
   ```assembly
   LOAD_A 14   ; A=11
   LOAD_B 15   ; B=5
   SUB B A     ; A=6 (11-5)
   JUMP_NEGATIVE 5  ; 正数→不跳
   JUMP 2      ; 跳回SUB
   ADD B A     ; A=1 (余数)
   STORE_A 13  ; 存结果
   HALT
   ```
   **执行流程**：
   1. 11-5=6 → 正数 → 继续循环
   2. 6-5=1 → 正数 → 继续循环
   3. 1-5=-4 → 负数 → 跳转到ADD
   4. -4+5=1 → 存结果 → 停止

   **结果**：11 ÷ 5 = 2 余 1（**用减法实现除法**）

> 💡 **Carrie Anne 的启示**：  
> *"ALU没有除法电路，但通过软件算法，  
> CPU能实现硬件不支持的功能——  
> 这就是抽象的力量！"*

---

### **指令集架构设计：两种主流策略**

1. 用更多位来代表指令 指令长度
2. 可变指令长度

#### 1. **固定长度指令**
| 特点                       | 优势         | 劣势                                            |
| -------------------------- | ------------ | ----------------------------------------------- |
| 所有指令等长 (如8/16/32位) | 解码简单快速 | 浪费空间<br>指令数量受限 (4位操作码→最多16指令) |
| **示例**：早期CPU          |              | 寻址能力有限 (4位地址→仅16位置)                 |

#### 2. **可变长度指令**

比如 某个CPU8位代表操作码 读取阶段更复杂

| 特点               | 工作原理                                                     | 优势                                       |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------ |
| 指令长度可变       | 1. 操作码确定后<br>2. 根据需要读取**立即值**(Immediate Value) | 高效利用空间<br>支持更多指令和更大寻址范围 |
| **示例**：JUMP指令 | `JUMP 17` = 8位操作码 + 8位地址                              | 可寻址256位置                              |

#### 3. **指令集规模演进**
| 时代     | 代表CPU       | 指令数量                 | 指令长度              |
| -------- | ------------- | ------------------------ | --------------------- |
| 1971     | Intel 4004    | 46                       | 8位操作码 + 8位立即值 |
| 现代     | Intel Core i7 | 数千                     | 1-15字节可变长度      |
| **趋势** | 指令功能特化  | 例如：仅ADD就有10+种变体 | 支持SIMD等高级操作    |

---

### **关键概念：程序执行的底层机制**
#### 1. **标志位(Flags)**
   - **负数标志(Negative Flag)**：ALU结果为负时置1
   - **作用**：为条件跳转提供判断依据
   - **示例**：`JUMP_NEGATIVE` 仅在标志=1时执行

#### 2. **指令执行周期**
   ```mermaid
   graph LR
   A[取指令] --> B[解码]
   B --> C{条件判断?}
   C -->|是| D[条件跳转]
   C -->|否| E[执行]
   D --> F[更新指令地址]
   E --> F
   F --> A
   ```

#### 3. **抽象层级的构建**
   - **硬件层**：ALU + 寄存器 + 控制单元
   - **指令层**：ADD/SUB/LOAD/STORE
   - **算法层**：用减法实现除法
   - **应用层**：实际计算任务

> ✅ **Carrie Anne 的总结**：  
> *"每一层抽象都建立在下层之上——  
> 16个基础指令 → 复杂算法 → 实用程序。  
> 这就是计算机从电路到智能的进化之路！"*

---

### **思考题：指令集设计的权衡**
1. **为什么现代CPU需要数千条指令？**  
   - 支持特定应用场景（图形处理、加密等）
   - 通过专用指令提升性能（如AVX指令集加速向量计算）

2. **固定长度 vs 可变长度指令的取舍**  
   - RISC架构（如ARM）：偏好固定长度 → 简化解码
   - CISC架构（如x86）：使用可变长度 → 更高效编码

3. **软件如何弥补硬件限制**  
   - 通过算法组合基础指令（如用移位+加法实现乘法）
   - 操作系统提供抽象层，隐藏硬件复杂性

---

**下集预告**：深入探讨 **"程序如何进入计算机"**，揭秘穿孔卡片、插线板等早期编程方式如何演变为现代软件加载机制！
