# 计算机科学速成课 Crash Course Computer Science

## 第十二集 编程原理：语句和函数（Programming Basics - Statements & Functions）

---

### **核心目标：理解编程语言的基础构建模块**
- **问题起点**：机器码（native machine code）编程繁琐且易错，阻碍复杂程序开发
- **关键突破**：通过**编程语言**实现**问题解决**与**硬件细节**的分离
- **核心理念**：**抽象**让程序员专注于"做什么"而非"怎么做"

> 💡 **Carrie Anne 的洞见**：  
> *"编程语言不是计算机的'外语'，而是人类思维与机器逻辑之间的'翻译器'——  
> 它让我们用`if/else`和`for`循环，指挥亿万晶体管协同工作！"*

---

### **编程语言基础：语句与变量**
#### 1. **语句（Statements）**
   - **定义**：**表达完整"思想"**的最小执行单元 ，用不同的词汇 可以代表不同含义

   - **类比**：自然语言中的完整句子（"我想要茶"）

   - **示例**：
     
   - **取名最好有点意义 ，方便别人读懂**
     
     ```python
     a = 5          # 赋值语句 创造一个 a的变量 ，把数字5放在里面 ，把一个值赋给一个变量
     score = 0      # 初始化语句
     bugs = level * 3  # 计算语句 
     
     ```
     
   - **关键特性**：
     - 必须符合语言**语法**（Syntax）
     
     - 无效组合 → 语法错误（如 `"I want raining"`）
     
       ![image-20250914203046306](.\image\image-20250914203046306.png)
     
       英语有语法，所有编程语言也都有语法
     
       

#### 2. **变量（Variables）**
   - **本质**：内存中命名的存储位置
   - **作用**：保存程序运行时的动态数据
   - **游戏示例**：
     ```python
     level = 1        # 当前关卡
     score = 0        # 玩家分数
     bugs = 5         # 剩余虫子数
     spare_relays = 4 # 备用继电器
     player_name = "Andre"  # 玩家名
     ```
   - **命名原则**：
     
     - ✅ 唯一性（避免冲突）
     - ✅ 可读性（`spare_relays` 比 `x` 更好）
     - ❌ 无意义名称（降低代码可维护性）

> ✅ **核心价值**：变量使程序能处理**动态变化**的数据（如游戏中的实时状态）
>
> 初始化 : 设置 最开始的值

---

### **控制流：改变程序执行顺序**
#### 1. **条件语句（If Statements）** Conditional Statements 
   - **结构**：
     
     ```python
     if [条件表达式]:
         # 条件为真时执行的代码
     else:
         # 条件为假时执行的代码
     END IF
     ```
   - **游戏应用**：根据关卡动态调整难度
     ```python
     if level == 1:
         bugs = 1  # 第1关只有1只虫子
     else:
         bugs = level * 3  # 后续关卡：虫子数 = 关卡×3
     ```
   - **执行流程**：
     ```mermaid
     graph LR
     A[条件表达式] -->|True| B[执行IF块]
     A -->|False| C[执行ELSE块]
     B --> D[继续后续代码]
     C --> D
     ```



​	![image-20250914220110789](.\image\image-20250914220110789.png)

* if 的具体 语法略有不同，但主体结构一样，if语句根据条件执行一次，如果希望根据条件执行多次，需要条件循环

#### 2. **循环结构（Loops）**

| 类型           | 工作原理           | 适用场景       | 游戏示例         |
| -------------- | ------------------ | -------------- | ---------------- |
| **While Loop** | 条件为真时重复执行 | 不确定执行次数 | 补充继电器直到满 |
| **For Loop**   | 按固定次数执行     | 已知执行次数   | 计算指数奖励     |

   - **While 循环示例**（补充继电器）：
     ```python
     while relays < 4:
         relays = relays + 1  # 每次+1
     ```
     ![image-20250914220530976](.\image\image-20250914220530976.png)
     
     **执行过程**：
     
     | 循环次数 | relays 初始值 | 条件检查    | 执行操作 | relays 新值 |
     | -------- | ------------- | ----------- | -------- | ----------- |
     | 1        | 1             | 1<4 → True  | +1       | 2           |
     | 2        | 2             | 2<4 → True  | +1       | 3           |
     | 3        | 3             | 3<4 → True  | +1       | 4           |
     | 4        | 4             | 4<4 → False | 退出循环 | -           |
     
   - **For 循环示例**（计算指数奖励）： 不判断条件，判断次数，会循环特定次数
     
     ```python
     bonus = 1
     for i in range(1, level+1):
         bonus = bonus * relays
     ```
     - **效果**：`bonus = relays^level`（继电器数的关卡次方）
     
     - **实例**：`relays=2, level=3` → `2×2×2 = 8`
     
       ![image-20250914220816221](.\image\image-20250914220816221.png)

> ✅ **关键区别**：  
> While 循环 = **"做直到条件满足"**  
> For 循环 = **"做N次"**

---

### **函数：抽象的核心机制**

这个指数代码很实用，其他地方可能会用到，如果每次想用就复制粘贴，会很麻烦 ，每次都要改 变量名

如果代码发生问题，要补漏洞时，要把每一个复制粘贴过的地方都找出来改，而且会让代码更难懂

![image-20250914221739132](.\image\image-20250914221739132.png)

#### 1. **函数定义与调用**
   - **本质**：可重用的代码封装单元
   - **结构**：
     ```python
     def 函数名(参数1, 参数2):
         # 函数体
         return 结果
     ```
   - **指数函数示例**：
     ```python
     def exponent(base, exp):
         result = 1
         for i in range(1, exp+1):
             result = result * base
         return result
     ```

#### 2. **函数调用流程**
   ```mermaid
   sequenceDiagram
     主程序->>exponent: 调用 exponent(2, 3)
     exponent->>exponent: 初始化 result=1
     exponent->>exponent: 循环3次 (2×2×2)
     exponent->>主程序: 返回 8
     主程序->>主程序: 使用结果
   ```

#### 3. **函数嵌套调用**
   - **游戏奖励系统示例**：
     ```python
     def calc_bonus(relays, level):
         if relays > 0:
             return exponent(relays, level)  # 调用exponent
         else:
             return 0
     
     def level_finished(relays, level, score):
         bonus = calc_bonus(relays, level)  # 调用calc_bonus
         new_score = score + bonus
         if new_score > high_score:
             high_score = new_score
             high_player = player_name
         return new_score
     ```
   - **执行链条**：  
     `level_finished()` → `calc_bonus()` → `exponent()`
     
     模块化编程，不仅可以让单人程序员独立制作App,也让团队协作可以写更大的程序

#### 4. **函数的四大价值**
| 价值           | 说明                   | 游戏示例                                   |
| -------------- | ---------------------- | ------------------------------------------ |
| **代码复用**   | 避免重复编写相同逻辑   | 多处调用`exponent()`                       |
| **复杂性隐藏** | 调用者无需了解内部实现 | `level_finished()`隐藏计算细节             |
| **模块化开发** | 团队可并行开发不同函数 | A开发`exponent()`，B开发`level_finished()` |
| **可维护性**   | 修改一处影响所有调用点 | 修复`exponent()`即修复所有使用处           |

> 💡 **Carrie Anne 的强调**：  
> *"现代软件中，超过100行的函数极为罕见——  
> 因为任何可提取的逻辑都应独立成函数！"*

---

### **抽象层级的演进：从机器码到现代开发**
#### 1. **抽象层级金字塔**
   ```mermaid
   graph BT
       A[机器码（0101...）] --> B[汇编语言（ADD, SUB）]
       B --> C[高级语言语句（赋值, 条件, 循环）]
       C --> D[函数/过程（封装代码）]
       D --> E[框架/库（高级抽象）]
   ```

#### 2. **抽象带来的变革**
   - **效率提升**：
     - 机器码：1行代码 ≈ 1个CPU指令
     - 高级语言：1行代码 ≈ 10+机器指令
   - **错误减少**：
     - 人类擅长逻辑，不擅长记二进制
     - 函数封装降低认知负荷
   - **协作可能**：
     - 模块化使千人团队协作成为可能
     - 标准库提供共同基础

#### 3. **库（Libraries）：站在巨人肩膀上**
   - **定义**：预编写的、经过测试的函数集合
   - **现代开发依赖**：
     - 网络库：处理HTTP请求
     - 图形库：渲染2D/3D图像
     - 数学库：高级计算
   - **关键优势**：
     - ✅ 避免重复造轮子
     - ✅ 专家优化的高性能实现
     - ✅ 经过严格测试的可靠性

> ✅ **现实意义**：  
> *"没有库，现代浏览器（数百万行代码）将无法由单人开发——  
> 抽象让不可能变为可能！"*

---

### **游戏案例深度解析：Grace Hopper抓虫子**
#### 1. **核心机制实现**
   ```python
   # 初始化游戏状态
   level = 1
   score = 0
   bugs = 5
   relays = 4
   player_name = "Andre"
   
   # 关卡完成处理
   def level_finished(relays, level, score):
       # 计算奖励分
       if relays > 0:
           bonus = 1
           for i in range(1, level+1):
               bonus = bonus * relays
       else:
           bonus = 0
       
       # 更新总分
       new_score = score + bonus
       
       # 检查是否破纪录
       if new_score > high_score:
           high_score = new_score
           high_player = player_name
       
       return new_score
   ```

#### 2. **抽象演进过程**
| 阶段   | 代码特点           | 问题               |
| ------ | ------------------ | ------------------ |
| 初版   | 内联计算奖励       | 重复代码、难以修改 |
| 优化1  | 提取exponent函数   | 仍需重复if逻辑     |
| 优化2  | 提取calc_bonus函数 | 逻辑分散           |
| 最终版 | level_finished封装 | 完整模块、可重用   |

#### 3. **关键设计原则**
   - **单一职责原则**：每个函数只做一件事
   - **参数化设计**：通过参数适应不同场景
   - **返回明确结果**：便于链式调用
   - **状态隔离**：避免全局变量污染

---

### **思考启示：编程语言的哲学本质**
1. **抽象不是逃避，而是聚焦**  
   - 低级细节 → 交给编译器/解释器  
   - 高级思维 → 专注问题解决  
   - *例：`exponent(2,44)` vs 手写18万亿计算*

2. **函数是思维的原子单位**  
   - 人类短期记忆限7±2个信息块  
   - 函数将复杂逻辑压缩为单一概念  
   - *例：`level_finished()` 封装了10+步骤*

3. **编程语言是认知工具**  
   - 扩展人类思维能力  
   - 将不可想象的问题（数百万行代码）  
     分解为可管理的单元

4. **现代软件开发的基石**  
   - 函数 → 类 → 模块 → 库 → 框架  
   - 每层抽象解决特定规模的问题  
   - *没有抽象，就没有现代软件*

> ✅ **Carrie Anne 的总结**：  
> *"编程语言的伟大不在于让计算机听懂人类，  
> 而在于让人类能理解计算机——  
> 通过层层抽象，我们将混沌的晶体管网络，  
> 转化为可思考、可构建的数字世界！"*

---

**下集预告**：深入探讨 **"算法"** ——计算机解决问题的**核心思维模式**，揭秘排序、搜索等基础算法如何影响你每天使用的科技产品！