# 计算机科学速成课 Crash Course Computer Science

前几集重点放在 计算机原理

## 第十集 早期的编程方式（Early Programming）

---

### **核心目标：理解计算机编程从物理操作到抽象思维的演进**
- **问题起点**：早期计算机没有"软件"概念，程序与硬件紧密耦合
- **关键突破**：从**物理连线**到**可存储程序**的范式转变
- **核心理念**：**编程的本质是抽象**，让人类思维与机器逻辑对接

> 💡 **Carrie Anne 的洞见**：  
> *"早期编程不是敲代码，而是'构建'计算过程——  
> 从雅卡尔织布机的穿孔卡片到ENIAC的插线板，  
> 人类花了170年让'编程'从物理操作  
> 变为抽象思维！"*

---

### **编程的起源：从纺织业到人口普查**
#### 1. **雅卡尔织布机（1804年）**
   - **问题**：如何让织布机自动编织复杂图案？
   - **解决方案**：**穿孔卡片**控制经线升降
     - 卡片孔位 → 决定横线（纬线）从上/下穿过
     - 卡片序列 → 形成**图案指令流**
   - **历史意义**：
     - 首次实现**可更换程序**（更换卡片序列即可改变图案）
     - 被公认为**最早的编程形式**

#### 2. **1890年美国人口普查**
   - **问题**：手工统计6200万人口数据效率低下
   - **解决方案**：赫尔曼·霍尔瑞斯的**穿孔卡片制表机**
     - 每张卡片 = 1个人的完整数据（种族/婚姻状况等）
     - 卡片孔位 = 特定答案（如"已婚"位置打孔）
   - **工作原理**：
     ```mermaid
     graph LR
     A[穿孔卡片] --> B{卡片插入制表机}
     B -->|有孔| C[对应计数器+1]
     B -->|无孔| D[计数器不变]
     C --> E[最终生成统计报告]
     ```
   - **局限**：仅能执行**固定功能**（统计），**不可编程**

> ✅ **关键启示**：穿孔卡片证明了**数据与程序的可编码性**，为现代编程奠定基础

---

### **早期编程的进化：从插线板到存储程序**
#### 1. **插线板编程（1920s-1940s）**

​	程序员需要某种 控制面包 control panel  运行不同程序要重新接线

   - **原理**：通过**物理连线**配置计算流程
     - 控制面板布满插孔
     - 程序员用线连接不同功能模块
   - **典型案例**：
     - **IBM 402会计机**：盈亏计算需复杂布线
     - **ENIAC（1946）**：世界首台通用电子计算机
       - 编程需**3周时间**重新布线
       - "程序" = 一捆实体电线
   - **致命缺陷**：
     - 硬件停机时间长（换程序=重接线）
     - 编程复杂度高（需理解硬件细节）

#### 2. **革命性突破：冯·诺依曼架构（1945）**

​	存在内存  Stored-Program Computers

   - **核心思想**：**程序与数据统一存储**
     - 内存同时存放指令+数据
     - CPU从内存读取指令执行
   - **五大组件**：
     1. 算术逻辑单元（ALU）
     2. 数据寄存器
     3. 指令寄存器
     4. 指令地址寄存器
     5. 统一内存（存程序+数据）
   - **划时代意义**：
     - ✅ **程序可快速切换**（无需重接线）
     - ✅ **程序可自我修改**（数据即指令）
     - ✅ **奠定现代计算机基础**（你正在用的设备仍是此架构）

#### 3. **首台实现：曼彻斯特"Baby"（1948）**
   - 世界首台**存储程序计算机**
   - 内存容量：**32×32位**（仅128字节！）
   - 首个程序：寻找2^36的最大因数
   - **验证了冯·诺依曼架构可行性**

> 💡 **Carrie Anne 的对比**：  
> *"插线板编程像重新布线整个房子，  
> 存储程序则像换电视频道——  
> 从物理重构到逻辑切换，  
> 这是编程思维的根本转变！"*

---

### **穿孔卡片时代：程序的物理载体**  程序和数据 依然需要某种方式输入计算机
#### 1. **工作原理**
   - 每张卡片 = 1条指令/1个数据

   - **读卡器将孔位转换为二进制 → 写入内存**

   - 卡片堆叠 → 形成完整程序

     ![image-20250914182011449](D:\Study\02_Crash_Course_Computer_Science\My-notes-about-CCCS\image\image-20250914182011449.png)

#### 2. **操作流程**
   ```mermaid
   sequenceDiagram
     程序员->>穿孔机: 输入代码
     穿孔机->>穿孔卡片: 打孔存储
     穿孔卡片->>读卡器: 插入卡片
     读卡器->>内存: 逐张读取写入
     CPU->>内存: 执行程序
   ```

#### 3. **现实挑战**
| 问题         | 具体影响                     | 应对方案                 |
| ------------ | ---------------------------- | ------------------------ |
| 卡片散落     | 62,500张SAGE系统需数周重排   | **斜条标记**（striping） |
| 程序规模     | 5MB数据需卡车运输            | 分批处理                 |
| 错误修正     | 修改需重新打孔整叠卡片       | 备份卡片集               |
| **典型案例** | 美国空军SAGE防空系统（1955） | 62,500张卡片 = 5MB       |

#### 4. **穿孔纸带：连续化改进**
   - 将离散卡片连成**连续纸带**
   - 优势：更紧凑、更易自动化处理
   - 应用：电报系统、早期计算机输入

> ✅ **关键数据**：SAGE系统穿孔卡片堆叠起来超过50米高，等同于5MB数据
> 穿孔纸卡的亲戚是纸带
> 最后除了 插线板和穿孔纸卡 
>
> panel program 与其插一堆线到插线板，可以用一大堆开关和按钮 ，做到一样的效果，面板上有指示灯 代表各种函数状态和内存中的值 
>
> 
>
> ![image-20250914182538356](D:\Study\02_Crash_Course_Computer_Science\My-notes-about-CCCS\image\image-20250914182538356.png)
>
> ![image-20250914182856207](D:\Study\02_Crash_Course_Computer_Science\My-notes-about-CCCS\image\image-20250914182856207.png)

---

### **面板编程：早期家用计算机的交互方式**
#### 1. **Altair 8800（1975）：家用计算机先驱**
   - **价格**：$400（组件版）≈ $2,000（2017年）
   - **编程方式**：
     1. 拨动**8位开关**输入二进制指令
     2. 按 **DEPOSIT** 存入内存
     3. 重复输入后续指令
     4. 按 **RUN** 执行，观察指示灯
     
     **早期的技术，都要非常了解底层硬件**

#### 2. **编程流程示例**
   ```
   1. 设置开关: 0010 1110 (LOAD_A 14)
   2. 按 DEPOSIT → 写入地址0
   3. 设置开关: 0001 1111 (LOAD_B 15)
   4. 按 DEPOSIT → 写入地址1
   5. ...（重复至程序完成）
   6. 开关拨回0 → 按 RUN
   7. 观察指示灯闪烁执行
   ```

#### 3. **时代局限性**
   - **仅限专家**：需记忆操作码和寄存器
   - **极易出错**：单个位错误导致程序崩溃
   - **效率低下**：输入100行程序需数小时

> 💡 **Carrie Anne 的幽默**：  
> *"在Altair 8800上编程就像用摩斯密码写小说——  
> 每个'点'和'划'都需手动切换，  
> 而且一个错误就要重来！"*

---

### **编程语言的诞生：从机器码到高级语言**
#### 1. **机器码编程的痛点**
   - **硬件依赖**：程序员需懂电路细节
   - **二进制输入**：易错且效率低下
   - **无抽象层**：无法复用代码

#### 2. **汇编语言：第一层抽象**
   - **原理**：用助记符代替二进制操作码
     - `ADD` 代替 `1000`
     - `LOAD_A` 代替 `0010`
   - **优势**：
     - ✅ 更易读写
     - ✅ 降低错误率
     - ✅ 保留对硬件的控制
   - **局限**：
     - ❌ 仍需理解硬件细节
     - ❌ 无高级抽象（如函数）

#### 3. **高级语言：革命性突破**
   - **关键创新**：
     - **编译器**：将高级代码转换为机器码
     - **抽象层级**：隐藏硬件细节
     - **结构化编程**：if/for等控制结构
   - **里程碑**：
     - **FORTRAN（1957）**：首个高级语言
     - **LISP（1958）**：函数式编程先驱
     - **COBOL（1959）**：商业应用语言

#### 4. **条件跳转的引入**
   - **JUMP指令**：无条件跳转到新位置
     - `JUMP 0` → 跳回程序开头
   - **条件跳转**：仅在特定条件下跳转
     - `JUMP_NEGATIVE`：仅当ALU负数标志=1时跳转
     - `JUMP_IF_EQUAL`：仅当比较相等时跳转
   - **意义**：实现程序分支与循环控制

> ✅ **关键启示**：条件跳转让计算机从"计算器"变为"可编程机器"

---

### **早期编程的核心挑战**
#### 1. **无限循环陷阱**
   ```assembly
   LOAD_A 14   ; A=1
   LOAD_B 15   ; B=1
   ADD B A     ; A=2
   STORE_A 13  ; 存结果
   JUMP 2      ; 永远跳回ADD
   HALT        ; 永远执行不到
   ```
   **问题**：缺少条件判断导致程序永远无法终止

#### 2. **条件循环实现**
   ```assembly
   LOAD_A 14   ; A=11
   LOAD_B 15   ; B=5
   SUB B A     ; A=6 (11-5)
   JUMP_NEGATIVE 5  ; 正数→不跳
   JUMP 2      ; 跳回SUB
   ADD B A     ; A=1 (余数)
   STORE_A 13  ; 存结果
   HALT
   ```
   **执行流程**：
   1. 11-5=6 → 正数 → 继续循环
   2. 6-5=1 → 正数 → 继续循环
   3. 1-5=-4 → 负数 → 跳转到ADD
   4. -4+5=1 → 存结果 → 停止

   **结果**：11 ÷ 5 = 2 余 1（**用减法实现除法**）

> 💡 **Carrie Anne 的洞见**：  
> *"ALU没有除法电路，但通过软件算法，  
> 早期程序员用减法实现了除法——  
> 这就是抽象思维的力量！"*

---

### **早期编程的哲学意义**
#### 1. **物理层 → 逻辑层的飞跃**
   - **穿孔卡**：程序 = **物理存在**（孔/无孔）
   - **存储程序**：程序 = **抽象数据**（0/1序列）
   - **本质突破**：程序从"硬件配置"变为"可操作对象"

#### 2. **抽象层级的构建**
   - **硬件层**：ALU + 寄存器 + 控制单元
   - **指令层**：ADD/SUB/LOAD/STORE
   - **算法层**：用减法实现除法
   - **应用层**：实际计算任务

#### 3. **冯·诺依曼架构的深层影响**
   - 允许**程序生成程序**（编译器/解释器基础）
   - 使**操作系统**成为可能（管理程序的程序）
   - 催生**软件产业**（脱离硬件的独立产业）

#### 4. **历史对现代的启示**
   - 今天**云计算**本质仍是冯·诺依曼架构
   - **AI训练**仍需解决"数据输入"问题（类似穿孔卡挑战）
   - 每次**交互方式革新**（GUI/语音/AR）都在降低编程门槛

> ✅ **关键数据**：1950年代1MB内存 ≈ $40万（现代≈$4百万），如今16GB内存仅$50

---

### **思考与延伸**
#### 1. **编程范式的演变**
| 时期  | 编程方式 | 抽象层级 | 典型应用   |
| ----- | -------- | -------- | ---------- |
| 1940s | 插线板   | 物理层   | 专用计算   |
| 1950s | 穿孔卡片 | 机器层   | 批处理任务 |
| 1960s | 汇编语言 | 指令层   | 系统编程   |
| 1970s | 高级语言 | 算法层   | 应用开发   |
| 2000s | 框架/API | 概念层   | 快速开发   |

#### 2. **现代编程的早期影子**
   - **DevOps**：早期"穿孔卡片"的现代版（代码即基础设施）
   - **低代码平台**：将编程简化为拖放操作
   - **AI编程助手**：自动补全代码，类似早期编译器

#### 3. **教育启示**
   - **理解底层**：学习机器码/汇编提升问题解决能力
   - **重视抽象**：理解不同抽象层级的价值
   - **动手实践**：通过模拟早期编程理解计算本质

#### 4. **未来展望**
   - **自然语言编程**：用日常语言编写程序
   - **脑机接口编程**：直接思维编程
   - **量子编程**：超越经典计算范式

> ✅ **Carrie Anne 的总结**：  
> *"早期编程的艰辛提醒我们：  
> 技术进步不是魔法，而是无数人的智慧结晶——  
> 从穿孔卡片到云端开发，  
> 每一步都建立在前人的肩膀上。  
> 下次你轻松敲出一行代码时，  
> 请记住这背后是170年的创新历程！"*

---

**下集预告**：深入探讨 **"编程语言基础"** ——揭秘语句、函数等编程基本构建模块，以及如何用`if/else`和`for`循环构建复杂程序！